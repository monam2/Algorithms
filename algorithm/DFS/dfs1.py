count = 0
def solution(board):
    global count
    total_count = []
    
    for i in range(5):
        for j in range(5):
            if board[i][j] == 1:
                count = 0
                DFS(i,j,board)
                total_count.append(count)
    return total_count
            
def DFS(x,y,board):
    global count
    board[x][y] = 0
    dx = [-1,0,1,0]
    dy = [0,1,0,-1]
    count += 1
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if (nx >= 0 and ny >= 0 and nx <= 4 and ny <= 4) and board[nx][ny] == 1:
            DFS(nx,ny,board)

'''
픽셀수구하기
5 * 5 이차원 배열에 모니터 화면을 표현합니다. 모니터의 화변은 최초 검정색과 흰색으로만
표현되어 있습니다. 검정색은 1, 흰색은 0으로 표현됩니다.
0 1 2 3 4
0 0 1 1 0 0
1 0 1 1 0 0
2 0 1 0 0 0
3 0 0 0 1 0
4 0 0 1 1 0
상하좌우로 1(검정색)이 연결되어 있으면 한 영역으로 간주합니다.
화면의 격자 정보가 위와 같다면 검정색으로 칠해진 영역은 2이고, 첫 번째 영역의 픽셀수(격
자수)는 5개이고, 두 번째 영역의 픽셀수는 3개입니다.
매개변수 board에 모니터 화면의 격자정보가 주어지면 검정색으로 칠해진 각 영역의 픽셀수를
순서대로 배열에 담아 반환하세요. 영역의 순서는 각 영역의 행번호, 열번호가 가장 작은 픽셀
을 기준으로 행번호가 작은 것부터이며 행번호가 같을 경우 열 번호가 작은 영역 순으로 배열
에 담습니다.
입출력 예:
제한사항:
• 검정색 영역은 1개 이상 반드시 존재합니다.
board answer
[[0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0,
0, 1, 0], [0, 0, 1, 1, 0]]
[5, 3]
[[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 1,
0, 1, 0], [1, 0, 1, 0, 0]]
[7, 2, 3, 1, 1]
[[0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0,
0, 1, 0], [0, 0, 1, 1, 0]]
[4, 1, 3]
[[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0,
0, 1, 0], [0, 0, 1, 0, 0]]
[1, 1, 1, 2, 1]
'''
print(solution([[0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
print(solution([[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 0], [1, 0, 1, 0, 0]]))
print(solution([[0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
print(solution([[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0]]))

